{% extends "base.html" %}
{% block title %}学習マップ{% endblock %}
{% block content %}
<article class="plan-container">
    <hgroup>
        <h1>インタラクティブ・学習マップ</h1>
        <p>科目を選択し、参考書をクリックして詳細を確認しよう</p>
    </hgroup>
    <div id="continuous-tasks-container" class="continuous-tasks-section"></div>

    <nav class="tabs subject-tabs">
        {% for subject in current_user.subjects|sort(attribute='id') %}
            <button class="tab subject-tab" data-subject="{{ subject.name }}">{{ subject.name }}</button>
        {% endfor %}
    </nav>
    <div id="plan-graph-container"></div>
</article>

<dialog id="task-modal">
    <article>
        <header>
            <a href="#close" aria-label="Close" class="close"></a>
            <h4 id="modal-title">参考書タイトル</h4>
        </header>
        <p id="modal-description">ここに説明が入ります。</p>
        <footer>
            <a id="modal-youtube-link" href="#" role="button" class="contrast" target="_blank" rel="noopener noreferrer">YouTubeで使い方を検索</a>
        </footer>
    </article>
</dialog>
{% endblock %}

{% block scripts %}
<script type="module">
    // plan.html の <script type="module"> の中

import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

document.addEventListener('DOMContentLoaded', () => {
    const subjectTabs = document.querySelectorAll('.subject-tab');
    const graphContainer = document.getElementById('plan-graph-container');
    const continuousContainer = document.getElementById('continuous-tasks-container');
    const modal = document.getElementById('task-modal');
    const modalCloseBtn = document.querySelector('#task-modal .close');

    function closeModal() { if (modal.hasAttribute("open")) modal.close(); }
    modal.addEventListener('click', (event) => { if (event.target === modal) closeModal(); });
    modalCloseBtn.addEventListener('click', closeModal);

    // ▼▼▼【新機能】継続タスクのリストを描画する関数 ▼▼▼
    function renderContinuousTasks(tasksByLevel) {
        continuousContainer.innerHTML = '<h3>レベル別・毎日のタスク</h3>';
        if (Object.keys(tasksByLevel).length === 0) {
            continuousContainer.innerHTML += '<p>この科目の毎日のタスクは準備中です。</p>';
            return;
        }

        const levelOrder = ['基礎徹底レベル', '高校入門レベル', '日東駒専レベル', 'MARCHレベル', '早慶レベル', '難関国公立・東大・早慶レベル'];

        levelOrder.forEach(level => {
            if (tasksByLevel[level]) {
                const levelWrapper = document.createElement('div');
                levelWrapper.className = 'level-group';

                let content = `<h4>${level}</h4><div class="task-grid">`;

                const tasksByCategory = tasksByLevel[level].reduce((acc, task) => {
                    if (!acc[task.category]) acc[task.category] = [];
                    acc[task.category].push(task);
                    return acc;
                }, {});

                for (const category in tasksByCategory) {
                    content += `<div class="category-group"><p><strong>${category}</strong></p>`;
                    tasksByCategory[category].forEach(task => {
                        // TODO: ここに選択ボタンや完了状態の表示を追加できます
                        content += `<button class="secondary outline" style="width: 100%; text-align: left;">${task.title}</button>`;
                    });
                    content += `</div>`;
                }
                content += `</div>`;
                levelWrapper.innerHTML = content;
                continuousContainer.appendChild(levelWrapper);
            }
        });
    }

    async function drawGraph(subjectName) {
        graphContainer.innerHTML = '<progress></progress>';
        continuousContainer.innerHTML = '';

        const response = await fetch(`/api/plan_data/{{ user.id }}/${subjectName}`);
        const data = await response.json();

        // ▼▼▼ 継続タスクの描画関数を呼び出す ▼▼▼
        if(data.continuous_tasks) {
            renderContinuousTasks(data.continuous_tasks);
        }

        const graphData = data.graph_data;
        graphContainer.innerHTML = '';
        if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
            graphContainer.innerHTML = '<p style="text-align: center; padding: 2rem;">学習ルートは準備中です。</p>';
            return;
        }

        const width = graphContainer.clientWidth;
        const height = graphData.nodes.length * 70;
        const margin = { top: 50, right: 120, bottom: 50, left: 20 };

        const y = d3.scalePoint().domain(graphData.nodes.map(d => d.id)).range([margin.top, height - margin.bottom]).padding(0.5);
        const categories = [...new Set(graphData.nodes.map(d => d.category))];
        const x = d3.scalePoint().domain(categories).range([margin.left, width - margin.right]);
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(categories);

        const svg = d3.select(graphContainer).append("svg")
            .attr("width", width).attr("height", height)
            .attr("viewBox", [0, 0, width, height]);

        const levels = d3.group(graphData.nodes, d => d.level);
        svg.append("g").selectAll("line").data(levels.keys()).join("line")
            .attr("x1", 0).attr("x2", width).attr("y1", d => y(levels.get(d)[0].id) - 40)
            .attr("y2", d => y(levels.get(d)[0].id) - 40).attr("stroke", "var(--pico-primary)").attr("stroke-dasharray", "4");
        svg.append("g").selectAll("text").data(levels.keys()).join("text")
            .attr("x", 20).attr("y", d => y(levels.get(d)[0].id) - 40)
            .attr("dy", "-0.5em").text(d => d).attr("font-size", "14px").attr("font-weight", "bold").attr("fill", "var(--pico-primary)");

        svg.append("g").selectAll("path").data(graphData.links).join("path")
            .attr("d", d => {
                const sourceNode = graphData.nodes.find(n => n.id === d.source);
                const targetNode = graphData.nodes.find(n => n.id === d.target);
                if (!sourceNode || !targetNode) return "";
                return `M${x(sourceNode.category)},${y(sourceNode.id)} L${x(targetNode.category)},${y(targetNode.id)}`;
            })
            .attr("fill", "none").attr("stroke", "#ccc").attr("stroke-width", 2);

        const node = svg.append("g").selectAll("g").data(graphData.nodes).join("g")
            .attr("transform", d => `translate(${x(d.category)},${y(d.id)})`)
            .style("cursor", "pointer")
            .on("click", (event, d) => {
                document.getElementById('modal-title').textContent = d.title;
                document.getElementById('modal-description').textContent = d.description;
                document.getElementById('modal-youtube-link').href = `https://www.youtube.com/results?search_query=${encodeURIComponent(d.youtube_query)}`;
                modal.showModal();
            });

        node.append("circle").attr("r", 12).attr("fill", d => colorScale(d.category))
            .attr("stroke", d => d.completed ? "#10B981" : "#fff").attr("stroke-width", 3);
        node.append("text").text(d => d.title).attr("x", 25).attr("y", 5).attr("font-size", "14px");
        node.filter(d => d.completed).append("text").text("✔")
            .attr("text-anchor", "middle").attr("dy", "0.35em").attr("fill", "white").attr("font-size", "12px");
    }

    function switchSubjectTab(targetTab) {
        if (!targetTab) return;
        subjectTabs.forEach(t => t.classList.remove('active'));
        targetTab.classList.add('active');
        const subjectName = targetTab.dataset.subject;
        drawGraph(subjectName);
    }

    subjectTabs.forEach(tab => {
        tab.addEventListener('click', (e) => switchSubjectTab(e.currentTarget));
    });

    if (subjectTabs.length > 0) {
        switchSubjectTab(subjectTabs[0]);
    }
});
</script>
{% endblock %}