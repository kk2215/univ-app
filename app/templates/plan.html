{% extends "base.html" %}
{% block title %}学習マップ{% endblock %}

{% block content %}
<article class="plan-container">
    <hgroup>
        <h1>インタラクティブ・学習マップ</h1>
        <p>科目を選択して、学習の全体像を掴もう</p>
    </hgroup>
    
    <nav class="tabs subject-tabs">
        {% for subject in current_user.subjects|sort(attribute='id') %}
            <button class="tab subject-tab" data-subject="{{ subject.name }}">{{ subject.name }}</button>
        {% endfor %}
    </nav>
    
    <div id="plan-graph-container"></div>
    <div id="tooltip" style="position: absolute; display: none; background: #fff; border: 1px solid #ccc; padding: 10px; border-radius: 5px;"></div>
</article>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    const subjectTabs = document.querySelectorAll('.subject-tab');
    const container = document.getElementById('plan-graph-container');
    const tooltip = document.getElementById('tooltip');
    
    // --- D3.js グラフ描画関数 ---
    async function drawGraph(subjectName) {
        // コンテナをクリアし、ローディング表示
        container.innerHTML = '<div class="loading-spinner"></div>';
        
        // APIからグラフデータを取得
        const response = await fetch(`/api/plan_data/{{ user.id }}/${subjectName}`);
        const data = await response.json();

        if (!data.nodes || data.nodes.length === 0) {
            container.innerHTML = '<p style="text-align: center; padding: 2rem;">この科目の学習ルートは準備中です。</p>';
            return;
        }

        container.innerHTML = ''; // ローディングを消去

        const width = container.clientWidth;
        const height = container.clientHeight;

        const svg = d3.select(container).append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height]);

        // 矢印マーカーを定義
        svg.append("defs").append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "-0 -5 10 10")
            .attr("refX", 23)
            .attr("refY", 0)
            .attr("orient", "auto")
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("xoverflow", "visible")
            .append("svg:path")
            .attr("d", "M 0,-5 L 10 ,0 L 0,5")
            .attr("fill", "#999");
        
        // 階層（レベル）ごとにy座標を決定
        const levels = [...new Set(data.nodes.map(d => d.level))];
        const levelScale = d3.scalePoint().domain(levels).range([height * 0.2, height * 0.8]);

        // シミュレーションを設定
        const simulation = d3.forceSimulation(data.nodes)
            .force("link", d3.forceLink(data.links).id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("x", d3.forceX(width / 2).strength(0.05))
            .force("y", d3.forceY(d => levelScale(d.level)).strength(0.5));

        const link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(data.links)
            .enter().append("line")
            .attr("class", "link")
            .attr("marker-end", "url(#arrowhead)");

        const node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("g")
            .data(data.nodes)
            .enter().append("g")
            .attr("class", "node")
            .call(drag(simulation));

        node.append("circle")
            .attr("r", 15)
            .attr("fill", d => d.completed ? "#28a745" : "#0d6efd");

        node.append("text")
            .text(d => d.title)
            .attr("x", 20)
            .attr("y", 5);

        node.on("mouseover", (event, d) => {
            tooltip.style.display = "block";
            tooltip.innerHTML = `<strong>${d.title}</strong><br>${d.level} - ${d.category}`;
        }).on("mousemove", (event) => {
            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
        }).on("mouseout", () => {
            tooltip.style.display = "none";
        });
        
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            node
                .attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // ドラッグ操作の関数
        function drag(simulation) {
          function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          }
          function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
          }
          function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          }
          return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }
    }

    // --- 科目タブの切り替え ---
    const subjectTabs = document.querySelectorAll('.subject-tab');
    function switchSubjectTab(targetTab) {
        if (!targetTab) return;
        subjectTabs.forEach(t => t.classList.remove('active'));
        targetTab.classList.add('active');
        const subjectName = targetTab.dataset.subject;
        drawGraph(subjectName);
    }
    subjectTabs.forEach(tab => {
        tab.addEventListener('click', (e) => switchSubjectTab(e.currentTarget));
    });

    // --- 初期表示 ---
    if (subjectTabs.length > 0) {
        switchSubjectTab(subjectTabs[0]);
    }
});
</script>
{% endblock %}